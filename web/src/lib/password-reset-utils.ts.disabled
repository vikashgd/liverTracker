import crypto from 'crypto';
import { prisma } from '@/lib/db';

// Token configuration
const TOKEN_EXPIRY_HOURS = 1; // Password reset tokens expire in 1 hour
const TOKEN_LENGTH = 32; // Length of the random token

/**
 * Generate a secure random token for password reset
 */
export function generatePasswordResetToken(): string {
  return crypto.randomBytes(TOKEN_LENGTH).toString('hex');
}

/**
 * Create a password reset token for a user
 */
export async function createPasswordResetToken(email: string): Promise<{ success: boolean; token?: string; error?: string }> {
  try {
    // Find user by email
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      // Don't reveal if email exists or not for security
      return { success: true }; // Return success even if user doesn't exist
    }

    // Generate token
    const token = generatePasswordResetToken();
    const expires = new Date(Date.now() + TOKEN_EXPIRY_HOURS * 60 * 60 * 1000);

    // Invalidate any existing unused tokens for this user
    await prisma.passwordReset.updateMany({
      where: {
        userId: user.id,
        used: false,
        expires: {
          gt: new Date()
        }
      },
      data: {
        used: true
      }
    });

    // Create new password reset token
    await prisma.passwordReset.create({
      data: {
        userId: user.id,
        token,
        expires,
        used: false
      }
    });

    return { success: true, token };
  } catch (error) {
    console.error('Error creating password reset token:', error);
    return { success: false, error: 'Failed to create password reset token' };
  }
}

/**
 * Validate a password reset token
 */
export async function validatePasswordResetToken(token: string): Promise<{ 
  valid: boolean; 
  userId?: string; 
  email?: string; 
  error?: string 
}> {
  try {
    // Find the token
    const resetToken = await prisma.passwordReset.findUnique({
      where: { token },
      include: {
        user: {
          select: {
            id: true,
            email: true
          }
        }
      }
    });

    if (!resetToken) {
      return { valid: false, error: 'Invalid or expired token' };
    }

    // Check if token is already used
    if (resetToken.used) {
      return { valid: false, error: 'Token has already been used' };
    }

    // Check if token is expired
    if (resetToken.expires < new Date()) {
      return { valid: false, error: 'Token has expired' };
    }

    return {
      valid: true,
      userId: resetToken.userId,
      email: resetToken.user.email || undefined
    };
  } catch (error) {
    console.error('Error validating password reset token:', error);
    return { valid: false, error: 'Failed to validate token' };
  }
}

/**
 * Use a password reset token (mark it as used)
 */
export async function usePasswordResetToken(token: string): Promise<{ success: boolean; error?: string }> {
  try {
    // Validate token first
    const validation = await validatePasswordResetToken(token);
    if (!validation.valid) {
      return { success: false, error: validation.error };
    }

    // Mark token as used
    await prisma.passwordReset.update({
      where: { token },
      data: { used: true }
    });

    return { success: true };
  } catch (error) {
    console.error('Error using password reset token:', error);
    return { success: false, error: 'Failed to use token' };
  }
}

/**
 * Clean up expired password reset tokens
 */
export async function cleanupExpiredTokens(): Promise<{ success: boolean; deletedCount?: number; error?: string }> {
  try {
    const result = await prisma.passwordReset.deleteMany({
      where: {
        OR: [
          { expires: { lt: new Date() } },
          { used: true }
        ]
      }
    });

    return { success: true, deletedCount: result.count };
  } catch (error) {
    console.error('Error cleaning up expired tokens:', error);
    return { success: false, error: 'Failed to cleanup tokens' };
  }
}

/**
 * Get all active password reset tokens for a user (for admin/debugging)
 */
export async function getUserActiveTokens(userId: string): Promise<{
  success: boolean;
  tokens?: Array<{ id: string; createdAt: Date; expires: Date; used: boolean }>;
  error?: string;
}> {
  try {
    const tokens = await prisma.passwordReset.findMany({
      where: {
        userId,
        used: false,
        expires: { gt: new Date() }
      },
      select: {
        id: true,
        createdAt: true,
        expires: true,
        used: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return { success: true, tokens };
  } catch (error) {
    console.error('Error getting user active tokens:', error);
    return { success: false, error: 'Failed to get active tokens' };
  }
}

/**
 * Generate password reset URL
 */
export function generatePasswordResetUrl(token: string, baseUrl?: string): string {
  const base = baseUrl || process.env.NEXTAUTH_URL || 'http://localhost:3000';
  return `${base}/auth/reset-password?token=${token}`;
}